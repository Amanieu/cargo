initSidebarItems({"enum":[["Cfg",""],["CfgExpr",""],["Freshness","Indication of the freshness of a package.A fresh package does not necessarily need to be rebuilt (unless a dependency was also rebuilt), and a dirty package must always be rebuilt."]],"mod":[["config",""],["errors",""],["graph",""],["hex",""],["important_paths",""],["job","Job management (mostly for windows)Most of the time when you're running cargo you expect Ctrl-C to actually terminate the entire tree of processes in play, not just the one at the top (cago). This currently works \"by default\" on Unix platforms because Ctrl-C actually sends a signal to the *process group* rather than the parent process, so everything will get torn down. On Windows, however, this does not happen and Ctrl-C just kills cargo.To achieve the same semantics on Windows we use Job Objects to ensure that all processes die at the same time. Job objects have a mode of operation where when all handles to the object are closed it causes all child processes associated with the object to be terminated immediately. Conveniently whenever a process in the job object spawns a new process the child will be associated with the job object as well. This means if we add ourselves to the job object we create then everything will get torn down!"],["lev_distance",""],["paths",""],["process_builder",""],["profile",""],["to_semver",""],["to_url",""],["toml",""]],"struct":[["DependencyQueue",""],["GitRepo",""],["HgRepo",""],["Rustc",""],["Sha256",""]],"trait":[["Dependency","A trait for discovering the dependencies of a piece of data."]]});